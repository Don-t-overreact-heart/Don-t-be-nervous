- Redux와 비슷한 다른 것들은 써보았는지?

  - ContextAPI

    Context는 수단일 뿐 사실상 상태관리 자체는 리액트 컴포넌트의 `useState`와 `useReducer`로 하게 되는 것 입니다.
    리덕스와의 주요 차이는 성능 면에서 나타나게 됩니다. 리덕스에서는 컴포넌트에서 글로벌 상태의 특정 값을 의존하게 될 때 해당 값이 바뀔 때에만 리렌더링이 되도록 최적화가 되어있습니다. 따라서, 글로벌 상태 중 의존하지 않는 값이 바뀌게 될 때에는 컴포넌트에서 낭비 렌더링이 발생하지 않겠지요. 반면 Context에는 이러한 성능 최적화가 이뤄지지 않았습니다. 컴포넌트에서 만약 Context의 특정 값을 의존하는 경우, 해당 값 말고 다른 값이 변경 될 때에도 컴포넌트에서는 리렌더링이 발생하게 됩니다.
    [https://ridicorp.com/story/how-to-use-redux-in-ridi/#:~:text=여기서 잠깐%2C 오해할 만한,성능 면에서 나타나게 됩니다](https://ridicorp.com/story/how-to-use-redux-in-ridi/#:~:text=%EC%97%AC%EA%B8%B0%EC%84%9C%20%EC%9E%A0%EA%B9%90%2C%20%EC%98%A4%ED%95%B4%ED%95%A0%20%EB%A7%8C%ED%95%9C,%EC%84%B1%EB%8A%A5%20%EB%A9%B4%EC%97%90%EC%84%9C%20%EB%82%98%ED%83%80%EB%82%98%EA%B2%8C%20%EB%90%A9%EB%8B%88%EB%8B%A4).

  - Constate

    Context를 사용하고 싶은데, 다뤄야하는 상태가 많아진 상황에서 성능도 챙겨가면서 개발도 편하게 하고 싶다면, [constate](https://github.com/diegohaz/constate) 라는 라이브러리 사용

    상태를 위한 Context와 상태 업데이트를 위한 Context를 따로 만들었던 작업을 하나의 함수로 간편하게 처리 할 수 있게 해줍니다.

    함수에 넣는 selector들을 기반으로 Context들이 자동으로 만들어지고, 해당 Context를 사용하는 Hook도 자동으로 만들어짐

  - Recoil
    - 상태 업데이트를 하기 위해서는 공통 조상 컴포넌트로 상태를 끌어올려야 하는데, 이 과정에서 너무 큰 트리가 리렌더링 될 수 있습니다.
    - Context를 사용 할 때 Consumer는 다양하게 사용되는데 Context에는 하나의 값만 담을수 있습니다.
    - 위 두가지 방식 모두 상태가 만들어지는 곳과 상태가 사용되는 곳의 코드 분리가 어렵습니다.
      컨텍스트의 다음과 같은 문제를 해결하기 위해 만들어진 상태관리 도구

- (saga를 써본 경우) saga와 thunk의 차이는? → 블로그 정리 글이 많음

  Redux Thunk가 함수를 디스패치 할 수 있게 해주는 미들웨어였다면, Saga는 액션을 모니터링 하고 있다가 특정 액션이 발생했을 때, 미리 정해둔 로직에 따라 특정 작업이 이루어지는 방식으로 이루어집니다. 또한 Sagas라는 순수함수들로 로직을 처리할 수 있는데, 순수함수로 이루어지다보니, 사이드 이펙트도 적고 테스트 코드를 작성하기에도 용이합니다.

  Redux Saga는 그 특성상 Thunk에 비해 많은 기능을 수행할 수 있습니다.

  [https://shinejaram.tistory.com/76#:~:text=다만 Thunk와는 방식이,이루어지는 방식으로 이루어집니다](https://shinejaram.tistory.com/76#:~:text=%EB%8B%A4%EB%A7%8C%20Thunk%EC%99%80%EB%8A%94%20%EB%B0%A9%EC%8B%9D%EC%9D%B4,%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%80%EB%8A%94%20%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C%20%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%91%EB%8B%88%EB%8B%A4).

  우선 Thunk는 Saga에 비해 **Boilerplate 코드가 적고 이해하기 쉽다**는 장점이 있습니다. 그만큼 서비스에 빠르게 적용할 수 있습니다. 따라서 **서비스의 로직이 작거나 규모가 작은 경우에는 Thunk를 사용**하는 것이 좀 더 나은 선택지라고 생각합니다. 하지만, Thunk의 경우 초보자가 잘못 사용할 경우 너무나 많은 async 로직을 구현하게 될 수도 있으며(비동기 로직이 복잡해짐), 또한 테스트를 하기 어려운 구조로 되어있어, **unit test를 자주 하는 환경에서는 적용하기 어렵다**는 단점을 가지고 있습니다.

  반면 Saga는 Thunk에 비해 초기에 구현해야 하는 Boilerplate의 양이 많고, 제너레이터 등의 개념을 알아야 하기 때문에 초기 러닝 커브도 높은 편입니다. 하지만, **Thunk에 비해 프로젝트 규모를 키우기 용이**하고, 여러 Saga의 **effects들을 활용**하면 Thunk에 비해 **깔끔한 로직을 구현**할 수 있습니다. 또한 Saga는 throttling, debouncing, api의 재요청 및 취소와 관련한 로직을 구현하기 용이하기 때문에, Thunk에 비해 활용도가 높다고 할 수 있습니다.

  개발 환경은 저마다 다르기 때문에 Thunk와 Saga 어떤 것이 더 낫다고 할 수 없습니다. 두 미들웨어의 사용법이 다른 만큼, 각자의 환경에 맞게 최적의 툴을 선택하여 적용하는 것이 좋은 개발이라고 할 수 있을 것입니다. 하지만 각자의 툴에 맞는 환경이 있듯이, 간단한 코드를 선호하시거나, 서비스 로직이 간단한 경우에는 Thunk를, 서비스 로직이 보다 크고 견고해야한다면 Saga를 쓰는 것을 추천드립니다.

- 전역관리를 사용할 상황이 무엇이며 이때 어떻게 대응하는지

### React 컴포넌트를 쪼개는 기준

1. 재사용성
2. 관심사 단위 (= 추상화)
3. 공통된 state가 사용되는 부분
4. 스테이트를 쉐어하기 위한 단위
5. api 연결을 위한 스테이트

### 트리 쉐이킹

트리 쉐이킹은 소스코드에서는 명시되어 있지만 실제로 프로그램 실행에 영향을 주지 않는 코드들을 빌드 단계 때 제거하는 것을 의미합니다. 이를 통해 번들 파일의 크기 최적화를 할 수 있습니다. 서비스 규모가 커짐에 따라 프로그래밍되는 코드가 많아지기 때문에 브라우저가 파일을 로드할때 시간을 많이 소비하게 됩니다. 이러한 상황에 트리 쉐이킹을 사용하면 파일 로드되는 시간이 줄어 사용자들이 더욱 빠른 속도로 서비스를 이용할 수 있습니다.

### SPA가 무엇인지?

SPA는 최초 요청시 서버에서 첫 페이지를 처리하고 이후의 라우팅은 클라이언트에서 처리하는 웹 애플리케이션이다.
장점

- 새롭게 페이지 로딩시의 깜빡임이 없어 자연스러운 사용자 경험(UX)
- 비동기적으로 필요한 리소스만 부분적으로 로딩(성능)
- 렌더링 관련 연산을 클라이언트로 분산하여 서버쪽 부하 줄여줌(성능)
- 컴포넌트별 개발 용이(생산성)
  단점
- 페이지에 필요한 모든 javascript를 한번에 받기때문에 초기 구동 속도 느림(code splitting으로 해결)
- 검색엔진최적화(SEO)가 어려움 (SSR 로 해결)

### CSR과 SSR의 차이점은?

**CSR**
웹서버에 요청할때 데이터가 없는 문서를 반환한다. HTML 및 static파일들이 로드 되면서 데이터가 있다면, 데이터 또한 서버에 요청하고 그것이 화면상에 나타나게 된다. Browser가 서버에 HTML과 static파일을 요청한 후 로드되면 사용자의 상호작용에 따라서 javascript를 통해 동적으로 Rendering한다. 필요에 따라 데이터를 서버에 요청해서 받아와 Rendring한다.
장점

- 첫 로딩에 HTML과 static파일들만 다 받으면, 동적으로 빠르게 Rendering하기 때문에 사용자 UX가 뛰어나다.
- 서버에 요청하는 횟수가 훨씬 적기 때문에 서버 부담이 덜하다.
  단점
- 모든 HTML과 static파일이 로드될 때까지 기다려야 한다.
- SEO(검색엔진 최적화) 문제가 발생할 수 있다.(검색엔진이 크롤링을 하는데 어려움)
  **SSR**
  완전하게 만들어진 HTML파일을 받아오고 Rendering하게 된다.
  웹서버에 요청할때 마다 Browser 새로고침이 일어나고 서버에 새로운 페이지에 대한 요청을 하는 방식.
  장점
- 초기 로딩 속도가 빠르기 때문에 사용자가 컨텐츠를 빨리 볼 수 있다.
- 모든 검색엔진에 대한 SEO(검색엔진 최적화)가 가능하다.
  단점
- 매번 페이지를 요청할 때마다 새로고침 되기 때문에 사용자 UX가 다소 떨어진다.
- 서버에 매번 요청을 하기 때문에 트래픽, 서버 부하가 커진다.

### 🔸 React 개발 시 SEO 관련 문제점

- 웹크롤러가 들어왔을때 html header의 meta태그나 body 컨텐츠가 비어있기 때문에 어떠한 정보를 제공하는 페이지인지 알 수 없다.
- 비동기로 렌더링 되는 페이지로 인해 구글봇과 같은 크롤러가 웹 페이지가의 내용을 크롤링 하기 어려워진다. ⇒ SPA의 단점

### 🔸 Redux 란?

**FLUX 패턴 :** 라이브러리나 프레임워크가 아닌 추상적인 개념 또는 아이디어로, 단방향 데이터 흐름 구조를 말한다.

![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/flux1.PNG)

- 사용자의 행위 `Action`은 `Dispatcher`에 의해 통제
- `Dispatcher`가 `Store`를 업데이트, 변경된 `Store`에 대한 `View`를 리렌더링
- `View`에서 `Store`에 직접 접근하지 않음, `Dispatcher`로 `Action`을 다시 보냄

**MVC 패턴 :** 쌍방향적인 데이터 흐름을 강조한 패턴

![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/mvc1.PNG)

- 여기서 `Model`과 `View`가 복잡하게 얽혀 있다면 어떤 `Model`이 변화되어 `View`가 변경되었는지 확인하기 어려워진다.
- 이를 해결하기 위해 단방향 데이터 흐름을 제어하는 FLUX 패턴이 등장

**Redux** : 상태관리 라이브러리중 하나로 FLUX를 기반으로 하는 단방향 데이터 흐름으로 상태관리를 할 수 있다.

### 🔸 Redux의 장점은 무엇이 있나요?(어떤 상황 예시 포함)

- MVC 패턴의 단점으로 페이스북 알림 버그가 있다.
  - 페이스북에 로그인 후 메시지 아이콘에 알림이 떠있다.
  - 그 메시지 아이콘을 클릭해서 들어가면 아무런 메시지가 없다.
  - 알림이 사라지고 몇 분 뒤 알림이 다시 나타나고 또 메시지가 나타나지 않는다.

⇒ MVC 패턴의 데이터 흐름은 디버그를 하기 어렵게 만든다.

- 단방향 데이터 흐름을 이용하면 어떤 액션이 `Dispatcher`에 의해 어떤 결과를 낳고 변화 되는지를 파악하기 쉬워진다.
- 데이터가 **집중화(Centralized)** 되어 있어서 **예측 가능하며(Predictable)** 데이터 흐름이 단방향이라서 **디버깅하기 쉽다(Debuggable)**

> [prepare_frontend_interview/React.md#리덕스에-대해서-아나요 ](https://github.com/junh0328/prepare_frontend_interview/blob/main/React.md#%EB%A6%AC%EB%8D%95%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%84%EB%82%98%EC%9A%94) > [리덕스는 왜 쓰는 건데](https://wooder2050.medium.com/%EB%A6%AC%EB%8D%95%EC%8A%A4-redux-%EB%8A%94-%EC%99%9C-%EC%93%B0%EB%8A%94-%EA%B1%B4%EB%8D%B0-2eaafce30f27) ⚡
> [React에서 Redux가 왜 필요할까?](https://devlog-h.tistory.com/26) > [리덕스 잘 쓰고 계시나요?](https://ridicorp.com/story/how-to-use-redux-in-ridi/)

### 🔸 Redux에서 준수해야할 3가지 원칙은?

- **진실은 하나의 소스로부터**

  애플리케이션의 모든 상태는 하나의 스토어 안에 하나의 객체 트리 구조로 저장됩니다.
  (응용 프로그램의 전역상태는 단일 저장소 내의 트리에 저장됩니다)

- **상태는 읽기 전용이다**

  상태를 변화시키는 유일한 방법은 무슨 일이 벌어지는 지를 묘사하는 액션 객체를 전달하는 방법 뿐입니다.

- **변화는 순수 함수로 작성되어야한다**

  액션에 의해 상태 트리가 어떻게 변화하는 지를 지정하기 위해 프로그래머는 순수 리듀서를 작성해야합니다.


### 🔸 라이프사이클 중 써본 메소드가 뭐가 있는지? 
1) render 메소드: 
컴포넌트를 렌더링할 때 필요한 메서드. 함수형 컴포넌트에서는 필요치 않다.
2) constructor: 
컴포넌트를 만들 때 처음으로 실행됨. 초기 state 를 설정할 수 있음.

```javascript 
// Class
class Example extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
}

// Hooks
const Example = () => {
    const [count,setCount] = useState(0);
}
```

### 🔸 함수형 컴포넌트와 클래스형 컴포넌트의 차이는? 
**클래스형**
클래스 형의 경우, state, lifeCycle 관련 기능을 사용할 수 있고, 메모리 자원을 함수형 컴포넌트 보다 조금 더 사용한다. 또한 임의 메서드를 정의할 수 있습니다.클래스 컴포넌트의 state는 객체 형식이며,  this.setState함수로 state이 값을 변경합니다.클래스 컴포넌트에서 props는 this.props를 통해 값을 불러옵니다.

**함수형** 
함수형 컴포넌트의 경우, state, lifeCycle관련 기능을 사용할 수 없지만 hooks를 통해 해결됩니다. 클래스형보다 컴포넌트의 선언이 편하다는 장점이 있습니다.
함수평 컴포넌트에서는 useState함수를 활용해 state를 사용합니다. 해당 함수를 사용하면 배열이 반환되며, 첫 번째 원소는 현재 상태, 두 번째 원소는 상태를 바꾸어 주는 함수입니다.
함수형 컴포넌트의 props는 불러올 필요 없이 바로 호출할 수 있습니다.


### 🔸 memo usememo usecallback
메모이제이션을 위해 사용하는 메서드
메모이제이션: 이전 값을 메모리에 저장해 동일한 계산의 반복을 제거하는 것. 빠른 처리를 가능케 하는 기술

**React.memo**
불필요한 렌더가 많이 발생하는 곳에서 사용함. 하나의 컴포넌트가 똑같은 props를 넘겨 받았을 때 같은 결과를 렌더링 하고 있다면 해당 메서드를 사용하여 불필요한 컴포넌트 렌더링을 방지할 수 있음. 이를 사용하여 렌더링 과정을 스킵하고 가장 최근에 렌더링된 결과를 재사용함.
해당 메서드는 넘겨받은 props의 변경 여부만 체크함.

```javascript 
// example
const MyComponent = React.memo((props) => {
 return (/*컴포넌트 렌더링 코드*/)}
);
```
**useMemo**
메모이즈 된 값을 return 하는 hook. 이전 값을 기억해두었다가 조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용됨.

```javscript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
인자로 함수와 dependencies를 넘겨받음. 두 번째 인자로 넘겨준 인자중에 값이 변경되면 첫 번째 인자의 함수를 재실행함. 렌더링 할때마다 소요되는 불필요한 계산을 피할 수 있음. dependencies 인자를 전달하지 않는다면 매번 새롭게 계산하여 return 함.

**useCallback**
렌더링 성능을 위해 제공되는 hook. 컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 생성되는 경우, 자식 컴포넌트에 prop으로 새로 생성된 함수가 넘겨지게 되면 불필요한 리렌더링이 일어날 수 있기 때문에 사용.

### 🔸 React Hooks 설명 및 사용했던 경험
함수형태의 컴포넌트에서 사용되는 몇가지 기술을 hook이라고 부르는데, 상태관리를 할 수 있는 useState, 렌더링 직후 작업을 설정하는 useEffect가 있다. 클래스형 컴포넌트는 문법이 어려우며, reloading의 신뢰성이 떨어지며, 최신 기술의 적용이 효과적이지 못하다.
함수형 컴포넌트에서 라이프사이클과 같은 기능을 사용할 수 있도록 하는 것이 hook이다.

간단한 투두리스트를 만들 때 useState를 사용하여, 투두 리스트에 들어가는 텍스트의 상태를 관리한다. todo와 setTodo를 선언하여 입력창의 값의 변화를 setTodo에 담아 변화에 따라 todo의 텍스트가 변화하도록 사용한 경험이 있다.  

