### **웹접근성 / 시맨틱 마크업**

- **웹접근성**
웹 접근성(Web Accessibility) 이란 장애인, 고령자 등이 웹 사이트에서 제공하는 정보에 비장애인과 동등하게 접근하고 이해할 수 있도록 보장하는 것이다.
그림이나 사진들을 제공할 때 눈으로 볼 수 없는 경우를 대비하여 그림이나 사진을 대신 할 수 있는 설명을 텍스트로 제공해야 하며, 동영상이나 오디오의 경우 청각장애인을 위한 음성정보를 문자로 제공해야 한다.

- **시맨틱 마크업**
시맨틱 마크업이란 의미를 잘 전달하도록 문서를 작성하는 것을 말합니다.

- 헤더/푸터에 `<header>` 와 `<footer>` 사용
- 메인 컨텐츠에 `<main>` 과 `<section>`, `<aside>` 사용
- 독립적인 컨텐츠에 `<article>` 사용
- 최상위 제목으로 `<h1>` 사용
- 순서가 없는 목록으로 `<ul>`과 `<li>` 사용
- 내비게이션 `<nav>` 사용
- 주소 `<address>` 사용
- `<details>`, `<figcaption>`, `<figure>`, `<mark>`, `<summary>`, `<time>` 기타 등등

이런 식으로 태그가 가지고 있는 의미에 맞게 사용하는 것인데, 이런 점 이외에도 `CSS` 스타일을 명시하는 태그를 사용하지 않는 것 또한 시맨틱 마크업의 한 종류이다. 즉, 태그가 가지는 의미 자체가 스타일이라면 이는 마크업 자체가 스타일을 갖는 것이기 때문에 시맨틱 마크업에 적합하지 않다.

- **시맨틱 마크업의 장점**
- **최적화** - 검색엔진이 시맨틱 태그를 중요한 키워드로 간주하기 때문에 검색엔진 최적화(SEO)에 유리합니다.
- **접근성** - 웹 접근성 측면에서, 시각장애가 있는 사용자로 하여금 그 의미를 훨씬 잘 파악할 수 있습니다.
- **개발**
  - 단순한 `div` , `span` 으로 둘러싸인 요소들보다 코드를 볼 때 가독성이 더 좋습니다.
  - 코드와 데이터의 재사용성이 높아짐


- **CSS 전처리기 (CSS-Preprocessor)**

  CSS가 가지는 여러 한계점을 극복하기 위해 탄생한 CSS의 확장 버전이라고 이해할 수 있습니다.

  종류로는 `SCSS, Less, Stylus`등이 있습니다.

    <aside>
    💡 장점

  - CSS의 유지보수성이 향상됩니다.
  - nesting 기능을 통해 중첩하여 작성해 가독성을 높일 수 있습니다.
  - 반복되는 CSS를 위한 Mixins 생성 가능합니다.
  - 코드를 여러 파일로 나눠서 코드 관리가 용이합니다.
  - Learning Curve가 낮습니다.
    </aside>

      <aside>
      💡 단점

  - 컴파일하기 위한 도구를 다시 설치해야 하고, 컴파일에 시간이 걸리기 때문에 성능이슈가 발생할 수 있습니다.
  </aside>

- **CSS Display 속성**

  ### none

  - 요소를 렌더링하지 않게 설정합니다. `visibility : hidden`과 다르게 영역도 차지하지 않습니다.

  ### block

  - 기본적으로 가로 영역을 모두 채우기 때문에 다음에 등장하는 요소는 줄바꿈이 된 것처럼 보입니다.
  - `width, height` 속성을 지정할 수 있습니다.

  ### inline

  - block과 달리 줄 바꿈이 일어나지 않고 contents 크기 만큼의 `width, height`를 가지고 있습니다.
  - `width, height`를 지정할 수 없습니다.

  ### inline-block

  - block 과 inline의 중간이라고 볼 수 있는데, 줄 바꿈이 일어나지 않지만 크기를 지정할 수 있습니다.

- **background img 와 img 태그의 차이점**

### styled-components 파일을 따로 분리를 한다고 하셨는데, 그랬을 때의 이점은 뭐가 있을까요?

+a 최근 웹 어플리케이션 개발을 여러 개의 재활용 가능한 컴포넌트 기반 개발 방법이 주류가 되고 있습니다. 그에 따라 HTML, CSS, JS를 한 파일에 모두 넣는 패턴이 많이 사용되고 있으며 그에 따라 React는 Jsx를 사용해서 이미 Js가 HTML을 포함하고 있는 형태를 취하고 있습니다. 여기에 CSS-in-JS 라이브러리인 styled-components를 사용한다면 손쉽게 CSS도 한파일에 삽입할 수 장점이 있습니다.

1. component 단위 스타일링
   styled-components는 중복되지 않는 특정 class 명을 생성해 스타일에 적용하기 때문에, className이 중복되거나 선택자우선순위에 혼선을 일으키는 문제는 미연에 방지할 수 있습니다.
2. 조건부 스타일링
   컴포넌트의 props를 전달받아 따른 가변 스타일링이 가능합니다. 템플릿 리터럴 내에서 Js가 사용하는 것과 같은 방식이며, 내부에서 선언된 함수는 props로 마라미터를 실행됩니다.
3. 확장 스타일링
   중복된 코드 양을 줄이고, 분산된 스타일을 일관적으로 관리 할 수 있어 유지보수 비용을 줄일 수 있습니다.
4. 중첩 스코프
   SASS의 중첩 스코프 규칙을 사용할 수 있습니다. 덕분에 내부의 모든 component를 styled-components로 생성하지 않아도, 하위 컴포넌트에게만 적용하고 싶은 스타일을 스코프 형태로 구현 할 수 있습니다. (주의: 모든 SASS 문법이 사용 가능하진 않습니다.)

### 만약에 styled-components 파일에서 로직이 필요하다고 하면 어떻게 하실 것 같으세요?

중복되는 스타일 요소는 확장 스타일링으로 대체할 것입니다.
특정 부분만 변화되는 로직이 필요하다면 props를 전달받아 조건부 스타일링을 할 것 입니다.

### CSS-in-JS를 많이 사용하셨는데 사용한 이유와 다른 컴포넌트를 검토해보셨는지 궁금합니다.
    
  css-in-js의 장점

  - CSS 모델을 문서 레벨이 아닌 컴포넌트 레벨로 추상화하는 모듈성
  - CSS-in-JS는 JavaScript 환경을 최대한 활용
  - 자바스크립트와 CSS 사이의 상수와 함수를 공유
  - 현재 사용 중인 스타일만 DOM에 포함
  - 짧은 길이의 유니크 한 클래스를 자동으로 생성하는 코드 경량화
 
### CSS-in-JS가 그냥 CSS 파일보다 성능이 떨어진다는 내용이 있는데 그런 부분도 고려를 해보셨을까요?
    
  CSS-in-JS의 단점

  - 새로운 의존성 발생
  - 별도의 라이브러리 설치에 따른 번들 크기 증가
  - CSS-in-CSS에 비해 느린 속도
      - CSS 파일이 추출되는 CSS 모듈 방식은 자바스크립트 해석 과정이 따로 없기 때문에 페이지가 훨씬 빨리 전환됩니다.

  이와 같은 단점들이 있지만, CSS-in-JS는 필요한 컴포넌트 페이지의 CSS 스타일 요소만 로딩하기 때문에 해당 프로젝트는 CSS-in-JS가 적합하다 생각했습니다. 
  사용자 편의에 방점을 둔 인터렉티브한 웹 프로젝트라면 랜더링 시 모든 CSS 스타일 요소를 로딩하는 CSS-in-CSS 을 고려하면 좋을 것 같습니다.

### 🔸 미디어쿼리(Media Query)

- 사이트에 접속하는 장치에 따라 특정한 CSS 스타일을 사용하도록 도와주는 소프트웨어 모듈
- 미디어 쿼리를 이용한 웹 사이트는 웹사이트에 접속하는 기기에 따라 레이아웃이 바뀐다.

⇒ 즉 반응형 웹을 구현하기 쉽도록 도와줍니다.
화면 크기마다 각각 다르게 CSS를 적용하는 것
화면 사이즈를 인식해 서로 다른 CSS를 적용시켜준다.

> 반응형 웹(Responsible Web)이란 디바이스(전자기기)별로 각각 레이아웃(grid)가 달라지는 웹이다.쉽게 설명하자면 화면의 크기 마다 레이아웃이 달라진다.

### 🔸 Debouncing(디바운싱) / Throttling(쓰로틀링)

- 디바운싱과 쓰로틀링은 UI에서 발생하는 이벤트를 제어하는 방법으로 과도하게 이벤트 처리 함수(콜백함수)가 호출되지 않도록 하여 부하방지를 위해 쓰이인다.
- Throttling : 사용자가 이벤트를 수행하는 동안 지정된 시간 간격으로 함수를 호출하는 방법
- Debouncing: 사용자가 특정 시간 동안 이벤트를 수행하지 않았을 때 함수를 호출하는 방법

> 예시)
> 이 기술을 쓰는 대표적인 사유는 검색어 자동완성기능이 있습니다.
> 아래와 같이 키보드 타이핑을 하면 검색어가 자동완성되는 아래와 같은 기능을 많이들 보셨을 겁니다. 예를 들어 쓰로틀링과 디바운싱을 안썼을 때, Italy 라는 단어를 검색해보자고 합시다.
> 그러면 클라이언트(웹브라우저)에서 서버로 요청(request) 보내어, 검색어에 일치하는 결과물들을 출력해줄 것입니다. I를 검색할때도, It까지 눌렀을때, Ita 까지 눌렀을대, Ital, Italy 라고 각각 타이핑할떄마다 request를 보내게 될 것입니다. 키보드 타이핑을 할 때마다 서버 요청을 하면 서버 부하도 증가하고, 클라이언트에서도 통신을 하느라 UI가 많이 느려져보이겠지요.
> 또한, api 횟수 제한이 있거나, 혹은 api 호출마다 비용이 든다면 서비스 운영에도 문제가 되겠지요. 그렇기에 request를 줄여 속도를 개선하기 위해 쓰로틀링과 디바운싱이 쓰이게 되었습니다.

### 🔸 Javascript 최적화를 위해 HTML 설계는 어떻게 해야하나요?

// 내용 더 찾아서 정리하겠습니다.

[렌더링 최적화 방법- 초기 렌더링 최적화](https://jsmokblog.tistory.com/21)

- HTML 구조 설명
    
  - HTML문서는 루트(root) 요소를 정의하는 `<HTML>` 태그로 시작하여 `</HTML>` 태그로 끝납니다. 그 내부는 HTML 문서의 메타데이터(metadata)를 정의하는`<head>` , 웹 브라우저를 통해 보이는 내용인 `<body>` 태그로 이루어져 있습니다. 메타데이터(metadata)란 HTML 문서에 대한 정보(data)로 웹 브라우저에는 직접적으로 표현되지 않는 정보를 의미합니다.
    
- CSS셀렉터 기본 형태 말고 어려워보이는걸 써본적 있는지
    
  - 자식, 형제, 가상클래스, 가상요소 등 복잡한 선택자를 사용해 본 경험이 있습니다. 기억에 남는 것을 예시로 들면, 상단 메뉴를 구현할 때, A B C D 메뉴가 있으면, A에 hover 시 A를 제외한 B,C,D의 opacity가 낮아지는 것을 구현해야 했던 적이 있습니다. menu들을 감싼 container에 hover 될 때, 자식 선택자로 전체 menu에 opacity : 0.5를 주고, 전체 menu 중 hover 된 menu만 opacity를 1로 유지시킴으로써 해결했었습니다.
```css
.header-menu-wrap:hover > *{
    opacity: 0.5;
}
.header-menu-wrap:hover > *:hover {
    opacity: 1;
}
```
